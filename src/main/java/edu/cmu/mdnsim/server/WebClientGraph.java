package edu.cmu.mdnsim.server;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import edu.cmu.mdnsim.config.Flow;
import edu.cmu.mdnsim.config.WorkConfig;
import edu.cmu.mdnsim.messagebus.message.WebClientUpdateMessage;
/**
 * Represents the actual state of the graph displayed in the web client. 
 * Should not be used for JSON conversion.
 * There needs to be only single object of this class.
 * 
 * The class internally uses ConcurrentHashMap for nodes and edges, 
 * 	but none of the add/remove methods provided by this class are synchronized 
 * 	=> Thread safety is same as guaranteed by ConcurrentHashMap  
 * 
 * @author Jeremy Fu
 * @author Vinay Kumar Vavili
 * @author Jigar Patel
 * @author Hao Wang
 */
public class WebClientGraph {

	Logger logger = LoggerFactory.getLogger("cmu-sv.mdn-manager.webclientgraph");
	/**
	 * Represents the Node in the graph displayed in web client
	 */
	public class Node{

		public static final String SRC_RGB = "rgb(0,204,0)";
		public static final String SINK_RGB = "rgb(0,204,204)";
		public static final String PROC_RGB = "rgb(204,204,0)";

		public static final String SRC_MSG = "This is a Source Node";
		public static final String SINK_MSG = "This is a Sink Node";
		public static final String PROC_MSG = "This is a Processing Node";

		public static final int NODE_SIZE_IN_GRAPH = 6;

		/**
		 * Unique value identifying the node
		 */
		public String id;
		/**
		 * This remains fixed i.e. always visible to user
		 */
		public String label;
		/**
		 * X location of the node in graph 
		 */
		public double x;
		/**
		 * Y location of the node in graph 
		 */
		public double y;
		/**
		 * Color of the node - specify in format "rgb(0,204,0)"
		 */
		public String color;
		/**
		 * Specifies size of the node (from 1 to 6). Not tried with large values (>6).
		 */
		public int size;
		/**
		 * Used to display tooltip on hover event. It can have html tags.
		 */
		public String tag;
		/**
		 * List of downstream nodes
		 */
		private List<Node> children;
		/**
		 * The type of node - Source/Sink/Processing/Relay etc.
		 */
		public String nodeType;
		public Node(String id, String label, String nodeType, String color,  int size, String tag){
			this(id,label,nodeType, -1,-1,color,size,tag);
		}

		public Node(String id, String label, String nodeType, double x, double y, String color, int size, String tag){
			this.id = id;
			this.label = label;
			this.x = x;
			this.y = y;
			this.color = color;
			this.size = size;
			this.tag = tag;
			this.nodeType = nodeType;
			this.children = new ArrayList<Node>();
		}

		/**
		 * Adds a new node to the children. 
		 * No validations done => Duplicates will be added multiple times.
		 * @param childNode
		 */
		public void addChild(Node childNode) {
			//if(!this.children.contains(childNode))
			this.children.add(childNode);
		}		
		@Override
		public int hashCode(){
			int res = 17;
			res = res*31 + this.id.hashCode();
			return res;
		}
		@Override
		public boolean equals(Object other){
			if(this == other)
				return true;
			if(!(other instanceof Node))
				return false;
			Node otherNode = (Node)other;
			return this.id.equals(otherNode.id);
		}
	}

	public class Edge{
		/**
		 * Unique value representing Edge. Generated by combining the source and target nodes.
		 */
		public String id;
		/**
		 * Represents the source node id
		 */
		public String source;
		/**
		 * Represents the target node id
		 */
		public String target;
		/**
		 * Type of edge - can be used to draw different types of edges.
		 * The value specified here can be used in javascript to modify the way edge is rendered.
		 */
		public String type;
		/**
		 * Used to display tooltip when mouse hovered over the edge. Can have html tags.
		 */
		public String tag;
		/**
		 * Indicates the stream status
		 */
		public String color;
		/**
		 * size of edge in numbers (it is relative size)
		 */
		public int size;

		public static final String EDGE_COLOR = "rgb(84,84,84)"; //Grey

		public static final int EDGE_SIZE_IN_GRAPH = 2;

		public Edge(String id, String source, String target, String type, String tag, String edgeColor, int size){
			this.id = id;
			this.source = source;
			this.target = target;
			this.type = type;
			this.tag = tag;
			this.color = edgeColor;
			this.size = size;
		}
		@Override
		public int hashCode(){
			int res = 17;
			res = res*31 + this.id.hashCode();
			return res;
		}
		@Override
		public boolean equals(Object other){
			if(this == other)
				return true;
			if(!(other instanceof Edge))
				return false;
			Edge otherEdge = (Edge)other;
			return this.id.equals(otherEdge.id);
		}
	}

	public class NodeLocation{
		public Double x;
		public Double y;
		public NodeLocation(Double x, Double y){
			this.x = x; this.y = y;
		}
		@Override
		public String toString(){
			return "x = " + this.x + ", y = " + this.y;
		}
		@Override
		public int hashCode(){
			int res = 17;
			res = res*31 + new Double(x).hashCode();
			res = res*31 + new Double(y).hashCode();
			return res;
		}
		@Override
		public boolean equals(Object other){
			if(this == other)
				return true;
			if(!(other instanceof NodeLocation))
				return false;
			NodeLocation nl = (NodeLocation)other;
			return this.x.equals(nl.x) && this.y.equals(nl.y);
		}
	}

	/**
	 * Key = Node Id, Value = Node
	 */
	private ConcurrentHashMap<String,Node> nodesMap;
	/**
	 * Key = Edge Id, Value = Edge
	 */
	private ConcurrentHashMap<String,Edge> edgesMap;

	private Node root;
	private int lastUsedXLocation = 0;

	/**
	 * Key = NodeType, Value = default node class based on its type
	 */
	private Map<String,Node> defaultNodeProperties;
	/**
	 * Private constructor to ensure that there is only one object of the Graph
	 */
	private WebClientGraph(){
		//TODO: Specify appropriate load factor, concurrency level for the maps 
		nodesMap = new ConcurrentHashMap<String,Node>();
		edgesMap = new ConcurrentHashMap<String,Edge>();

		//Create a virtual root node and add it to nodes Map.
		//Required for calculating node locations
		root = new Node("","Virtual Root Node","","",0,"");
		nodesMap.put(root.id, root);
		
		defaultNodeProperties = new HashMap<String,Node>();
		init();
	};	
	/**
	 * Whenever a new Node Type is added, make changes here to set default color, Y location and other properties of that node type
	 */
	private void init() {
		defaultNodeProperties.put(WorkConfig.SOURCE_NODE_TYPE_INPUT, 
				new Node("","",WorkConfig.SOURCE_NODE_TYPE_INPUT,-1,10,Node.SRC_RGB,Node.NODE_SIZE_IN_GRAPH,Node.SRC_MSG));
		defaultNodeProperties.put(WorkConfig.PROC_NODE_TYPE_INPUT, 
				new Node("","",WorkConfig.PROC_NODE_TYPE_INPUT,-1,30,Node.PROC_RGB,Node.NODE_SIZE_IN_GRAPH,Node.PROC_MSG));
		defaultNodeProperties.put(WorkConfig.SINK_NODE_TYPE_INPUT, 
				new Node("","",WorkConfig.SINK_NODE_TYPE_INPUT,-1,50,Node.SINK_RGB,Node.NODE_SIZE_IN_GRAPH,Node.SINK_MSG));

	}
	public final static WebClientGraph INSTANCE = new WebClientGraph();
	//private static final int VERTICAL_DISTANCE_BETWEEN_NODES = 20;
	private static final int HORIZANTAL_DISTANCE_BETWEEN_LEAF_NODES = 10;

	/**
	 * Gets the node from the graph. Returns null if not present.
	 * @param nodeId
	 * @return
	 */
	public Node getNode(String nodeId){
		return nodesMap.get(nodeId);
	}
	/**
	 * If the node already exists it it over written
	 * @param n
	 */
	public void addNode(Node n) {
		nodesMap.put(n.id, n);
	}
	/**
	 * If the edge already exists it is overwritten
	 * @param e
	 */
	public void addEdge(Edge e) {
		edgesMap.put(e.id, e);
	}
	public void removeNode(Node n){
		nodesMap.remove(n.id);
		//TODO: Check if we need to remove corresponding edges here or let the user of this class handle it?
	}
	public void removeEdge(Edge e){
		edgesMap.remove(e.id);
		//TODO: Check if we need to remove corresponding nodes or let the user of this class handle it?
	}

	/**
	 * Used to generate WebClient Update Message - 
	 *  which can be easily converted JSON and parsed by the client code (javascript code)
	 * This version of the over-loaded method returns the entire set of nodes and edges 
	 * even though some nodes may not be operational yet 
	 * @return
	 */
	public WebClientUpdateMessage getUpdateMessage(){
		WebClientUpdateMessage msg = new WebClientUpdateMessage();
		msg.setNodes(this.nodesMap.values());
		msg.setEdges(this.edgesMap.values());
		return msg;
	}

	/**
	 * Used to generate WebClient Update Message - 
	 *  which can be easily converted JSON and parsed by the client code (javascript code)
	 *  This version of the over-loaded method returns the set of nodes and edges which are 
	 *  operational. (i.e. registered with the master)
	 * @param operationalNodes
	 * @return
	 */
	public WebClientUpdateMessage getUpdateMessage(Set<String> operationalNodes) {
		WebClientUpdateMessage msg = new WebClientUpdateMessage();
		List<Node> operationalNodeSet = new ArrayList<Node>();
		List<Edge> operationalEdgeSet = new ArrayList<Edge>();

		for (String nodeId : operationalNodes)
			operationalNodeSet.add(this.getNode(nodeId));
		msg.setNodes(operationalNodeSet);

		/* Add the edge to be displayed in the graph only if both end points of 
		 * the edge are up
		 */
		for (Edge e : this.edgesMap.values()) {
			String[] nodes = e.id.split("-");
			if (operationalNodes.contains(nodes[0]) && operationalNodes.contains(nodes[1]))
				operationalEdgeSet.add(e);
		}
		msg.setEdges(operationalEdgeSet);
		return msg;
	}

	/**
	 * Returns edge if available else null
	 * @param edgeId
	 * @return
	 */
	public Edge getEdge(String edgeId){
		return edgesMap.get(edgeId);
	}

	/**
	 * Check whether the node is contained in the graph.
	 * 
	 * @param nodeId
	 * @return
	 */
	public boolean containsNode(String nodeId) {
		return nodesMap.containsKey(nodeId);
	}

	/**
	 * If the node already exists it doesn't add the node to the graph
	 * @param n
	 */
	public void addNode(Map<String, String> nodePropertiesMap) {
		String nodeId = nodePropertiesMap.get(Flow.NODE_ID);
		if (this.containsNode(nodeId)) {
			return;
		}
		String nodeType = nodePropertiesMap.get(Flow.NODE_TYPE);

		Node newNode = new Node(nodeId, nodeId, nodeType,
				this.defaultNodeProperties.get(nodeType).color, 
				this.defaultNodeProperties.get(nodeType).size, 
				this.defaultNodeProperties.get(nodeType).tag);
		newNode.y = this.defaultNodeProperties.get(nodeType).y;
		nodesMap.put(newNode.id, newNode);		

	}
	/**
	 * If the edge already exists it doesn't add it to the graph.
	 * Both the nodes should be added to the web client graph other wise it will behave abnormally
	 * This function will also set the children property of the nodes involved.
	 * @param e
	 */
	public void addEdge(Map<String, String> nodeMap) {
		String nodeId = nodeMap.get(Flow.NODE_ID);
		String upStreamNodeId = nodeMap.get(Flow.UPSTREAM_ID);
		String edgeId = getEdgeId(upStreamNodeId, nodeId);

		if (containsEdge(edgeId)) {
			return;
		}
		//Consider Source Node when setting children property as Source nodes will be child of Virtual root 
		addChild(nodeId, upStreamNodeId);
		//Ignore Source nodes when adding edges to be displayed in graph
		if(!upStreamNodeId.equals("NULL")){
			Edge newEdge = new Edge(edgeId, upStreamNodeId, 
					nodeId, "", edgeId, Edge.EDGE_COLOR, 
					Edge.EDGE_SIZE_IN_GRAPH);

			edgesMap.put(newEdge.id, newEdge);
		}
	}

	public boolean containsEdge(String edgeId) {
		return edgesMap.containsKey(edgeId);
	}

	public static String getEdgeId(String srcId, String dstId) {
		return srcId + "-" + dstId;
	}
	/**
	 * Adds the node with id = nodeId as child of node with id = parentNodeId
	 * If the nodes are not present in the graph, does nothing
	 * @param nodeId
	 * @param parentNodeId
	 */
	private void addChild(String nodeId, String parentNodeId) {
		if(this.getNode(nodeId) != null){
			if(parentNodeId.equals("NULL")){
				root.addChild(this.getNode(nodeId));
			}else{
				if(this.getNode(parentNodeId) != null)
					this.getNode(parentNodeId).addChild(this.getNode(nodeId));
			}
		}
	}
	/**
	 * Sets the X location for all the nodes in graph based on tree concept with virtual node as root
	 * Y location is fixed based on Node Type 
	 * Ensure that all nodes are part of the graph and their children property is set before calling this method  
	 * It will reset positions for all nodes and start fresh
	 */
	public void setLocations(){
		lastUsedXLocation =  0;
		setLocations(root);		
	}
	private void setLocations(Node n) {
		if(n == null) return;
		if(n.children.size() > 0){
			for(Node child : n.children)
				setLocations(child);
			if(n.children.size() == 1){
				//Place it just above the child
				n.x = n.children.get(0).x;
			}else{
				//Place the node in middle of leftmost and rightmost children
				n.x = n.children.get(0).x + ((n.children.get(n.children.size()-1).x - n.children.get(0).x)/2); 
			}			
		}else{
			//For leaf nodes, just add fixed value to last X value
			n.x = this.lastUsedXLocation  + HORIZANTAL_DISTANCE_BETWEEN_LEAF_NODES;	
			this.lastUsedXLocation += HORIZANTAL_DISTANCE_BETWEEN_LEAF_NODES;
		}

		logger.debug(String.format("%s,%s,%s",n.nodeType,n.x,n.y));
		System.out.println(String.format("%s,%s,%s",n.id,n.x,n.y));
	}
}
